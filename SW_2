#pragma config POSCMOD = XT      // Primary Oscillator Select (XT Oscillator mode selected)
#pragma config OSCIOFNC = ON     // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as port I/O (RC15))
#pragma config FCKSM = CSDCMD    // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
#pragma config FNOSC = PRI       // Oscillator Source Selection (Primary Oscillator (XT, HS, EC))
#pragma config IESO = ON         // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) enabled)

// Watchdog Timer
#pragma config WDTPS = PS32768   // Watchdog Timer Postscaler (1:32,768)
#pragma config FWPSA = PR128     // WDT Prescaler (Prescaler ratio of 1:128)
#pragma config WINDIS = ON       // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
#pragma config FWDTEN = OFF      // Watchdog Timer Enable (Watchdog Timer is disabled)

// Comm Channell select
#pragma config ICS = PGx2        // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC2/PGED2)
#pragma config GWRP = OFF        // General Code Segment Write Protect (Writes to program memory are allowed)
#pragma config GCP = OFF         // General Code Segment Code Protect (Code protection is disabled)
#pragma config JTAGEN = OFF      // JTAG Port Enable (JTAG port is disabled)


#define FCY 4000000UL // Instruction cycle frequency (FOSC/2) - assuming 8MHz crystal

#include <libpic30.h>
#include <xc.h>
#include <stdbool.h> // For bool type
#include <stdint.h>  // For uintN_t types

#define PROGRAM_JEDEN  1
#define PROGRAM_DWA    2

typedef enum
{
    ADC_CHANNEL_POTENTIOMETER = 5, // AN5 for potentiometer
    // Add other channels if needed
} ADC_CHANNEL;

#define ADC_CONFIGURATION_DEFAULT 0

volatile unsigned char currentProgram = PROGRAM_JEDEN;
volatile bool zmienProgram = false; // Use bool from stdbool.h
volatile uint16_t dynamic_delay_ms = 500; // Global variable for dynamic delay

// --- Function Prototypes ---
void init(void);
void jeden(void);
void dwa(void);
void update_delay_from_adc(void);
bool ADC_SetConfiguration(uint8_t configuration);
uint16_t ADC_Read10bit(ADC_CHANNEL channel);
// bool ADC_ChannelEnable(ADC_CHANNEL channel); // Not strictly needed if AD1PCFG set directly

// --- ADC Functions ---
bool ADC_SetConfiguration(uint8_t configuration) {
    if (configuration == ADC_CONFIGURATION_DEFAULT) {
        AD1CON1bits.ADSIDL = 0; // Continue module operation in Idle mode
        AD1CON1bits.FORM = 0b00; // Data Output Format: Integer (DOUT = 0000 dddd dddd dddd)
        AD1CON1bits.SSRC = 0b000; // Sample Clock Source: Manual, clearing SAMP bit ends sampling and starts conversion
        AD1CON1bits.ASAM = 0;   // ADC Sample Auto-Start: Sampling begins when SAMP bit is set

        AD1CON2bits.VCFG = 0x0; // Voltage Reference Configuration: AVdd and AVss
        AD1CON2bits.CSCNA = 0;  // Do not scan inputs
        AD1CON2bits.SMPI = 0x0; // Converts CH0 an (SMPI+1) number of times
        AD1CON2bits.BUFM = 0;   // Buffer configured as one 16-word buffer

        AD1CON3bits.ADRC = 0;   // ADC Clock Source: Clock derived from system clock
        AD1CON3bits.SAMC = 0b10000; // Auto Sample Time: 16 TAD ( बट AD1CON1bits.ASAM = 0 and SSRC = 000, so sample time is manually controlled)
        AD1CON3bits.ADCS = 0x07; // ADC Conversion Clock Select: TAD = TCY * (ADCS + 1) = TCY * 8
                                 // If FCY = 4MHz, TCY = 250ns. TAD = 2us. Min TAD for PIC24F often ~118ns. This is fine.
                                 // Original was 0xFF (very slow TAD = 128us)

        AD1CON1bits.ADON = 1;   // Turn on ADC module
        return true;
    }
    return false;
}

uint16_t ADC_Read10bit(ADC_CHANNEL channel) {
    uint16_t i; // For NOP loop if used, otherwise can be removed if __delay_us is used

    // Ensure channel is valid before setting AD1CHS
    // This simple switch from original code is okay for the given enum
    switch(channel) {
        case ADC_CHANNEL_POTENTIOMETER: // AN5
            break;
        // case ADC_CHANNEL_4: // Example if AN4 was also used
        //     break;
        default:
            return 0xFFFF; // Invalid channel or error
    }

    AD1CHS = channel;           // Select ADC channel

    AD1CON1bits.SAMP = 1;       // Start sampling
    // __delay_us(20);          // Minimum acquisition time (e.g. 20us).
                                // Original NOP loop: 1000 * Nop() @ 4MIPS (TCY=250ns) = 250us. This should be sufficient.
    for(i=0; i<200; i++) { Nop(); } // Reduced NOP loop for ~50us sample time (adjust as needed)

    AD1CON1bits.SAMP = 0;       // Start conversion

    // DO NOT put a delay loop here before checking DONE bit.
    while (!AD1CON1bits.DONE);  // Wait for conversion to complete
    AD1CON1bits.DONE = 0;       // Clear conversion done bit (good practice)
    
    return ADC1BUF0;            // Read ADC result
}

/*
// This function might not be needed if AD1PCFG is set directly in init() before ADON.
bool ADC_ChannelEnable(ADC_CHANNEL channel) {
    switch(channel) {
        case ADC_CHANNEL_POTENTIOMETER: // AN5
            AD1PCFGbits.PCFG5 = 0; // Configure AN5 as analog input
            return true;
        // Add other cases if needed
        default:
            return false;
    }
}
*/

// --- Subprogram Speed Update ---
void update_delay_from_adc(void) {
    uint16_t adc_val = ADC_Read10bit(ADC_CHANNEL_POTENTIOMETER);

    if (adc_val == 0xFFFF) { // Error reading ADC, maintain current speed
        return;
    }

    // Map 10-bit ADC value (0-1023) to 5 speed levels
    if (adc_val < 205) dynamic_delay_ms = 100;       // Fastest
    else if (adc_val < 410) dynamic_delay_ms = 250;
    else if (adc_val < 615) dynamic_delay_ms = 500;  // Medium
    else if (adc_val < 820) dynamic_delay_ms = 750;
    else dynamic_delay_ms = 1000;                    // Slowest
}


// --- Subprograms ---
void jeden() { // Counts from 0 to 255 on LATA (lower 8 bits)
    unsigned char counter = 0;
    LATA = counter; // Set initial state for this program run

    while (!zmienProgram) {
        update_delay_from_adc(); // Update speed based on potentiometer
        
        LATA = counter;
        counter++; // Unsigned char will wrap from 255 to 0

        // Custom delay loop to allow breaking by interrupt
        for (uint16_t i = 0; i < dynamic_delay_ms; ++i) {
            __delay_us(999); // Approx 1ms, fine tune if needed, __delay_us(1000) can be an issue with some compilers for exact values.
            if (zmienProgram) break; // Exit delay early if program change requested
        }
        if (zmienProgram) break; // Exit subprogram loop
    }
}

void dwa() { // "Snake" or shifting pattern on LATA (lower 8 bits)
    uint8_t waz = 0b00000111; // Initial 3-bit pattern
    uint8_t kierunek = 1;     // 1 for left shift, 0 for right shift
    LATA = waz; // Set initial state for this program run

    while (!zmienProgram) {
        update_delay_from_adc(); // Update speed based on potentiometer

        if (kierunek == 1) { // Shifting left
            waz <<= 1;
            if (waz == 0b11100000 || waz == 0) { // Check boundary or if pattern shifted out
                waz = 0b01110000; // Prepare for right shift
                kierunek = 0;
            }
        } else { // Shifting right
            waz >>= 1;
            if (waz == 0b00000111 || waz == 0) { // Check boundary or if pattern shifted out
                waz = 0b00001110; // Prepare for left shift
                kierunek = 1;
            }
        }
        // Ensure waz has a valid pattern if it becomes 0 (e.g. if LATA is wider than 8 bits and waz is uint8_t)
        if (waz == 0) waz = 0b00000001; // Re-initialize if it becomes all zero

        LATA = waz; // Update LEDs

        // Custom delay loop
        for (uint16_t i = 0; i < dynamic_delay_ms; ++i) {
            __delay_us(999);
            if (zmienProgram) break;
        }
        if (zmienProgram) break;
    }
}

// --- Interrupt Service Routine for Change Notification (Buttons) ---
void __attribute__((interrupt, auto_psv)) _CNInterrupt(void) {
    __delay_ms(20); // Basic debouncing (consider alternative methods for critical applications)

    // RD6 (e.g., CN15) - "Next Program" button
    if (!PORTDbits.RD6) {
        if (currentProgram == PROGRAM_JEDEN) {
            currentProgram = PROGRAM_DWA;
        } else { // Was PROGRAM_DWA
            currentProgram = PROGRAM_JEDEN;
        }
        // Or more generically if more programs:
        // currentProgram++;
        // if (currentProgram > MAX_PROGRAM_NUMBER) {
        //     currentProgram = FIRST_PROGRAM_NUMBER;
        // }
        zmienProgram = true;
    }

    // RD13 (e.g., CN19) - "Previous Program" button
    if (!PORTDbits.RD13) {
        if (currentProgram == PROGRAM_JEDEN) {
            currentProgram = PROGRAM_DWA;
        } else { // Was PROGRAM_DWA
            currentProgram = PROGRAM_JEDEN;
        }
        // Or more generically:
        // if (currentProgram == FIRST_PROGRAM_NUMBER) {
        //     currentProgram = MAX_PROGRAM_NUMBER;
        // } else {
        //     currentProgram--;
        // }
        zmienProgram = true;
    }

    IFS1bits.CNIF = 0; // Clear Change Notification Interrupt Flag
}

// --- Initialization Function ---
void init(void) {
    // --- Oscillator Configuration ---
    // Assumed to be configured by #pragma directives and FCY definition

    // --- Port A for LEDs ---
    TRISA = 0x0000; // Set PORTA as output
    LATA = 0x0000;  // Turn off all LEDs initially

    // --- Port D for Buttons (RD6, RD13) ---
    TRISDbits.TRISD6 = 1;  // RD6 (e.g., CN15) as input
    TRISDbits.TRISD13 = 1; // RD13 (e.g., CN19) as input
    // ANSELDbits.ANSD6 = 0; // If RD6 has analog function, set to digital
    // ANSELDbits.ANSD13 = 0; // If RD13 has analog function, set to digital
                            // For many PIC24, RD pins are digital by default or don't have analog. Check datasheet.
    
    // Optional: Enable internal pull-ups if no external ones
    // Exact register names (e.g., CNPU1, CNPU2 or CNPUDx) depend on the specific PIC24 device.
    // Example for devices with CNPUx registers:
    // CNPU1bits.CN15PUE = 1; // Enable pull-up for CN15 (RD6)
    // CNPU2bits.CN19PUE = 1; // Enable pull-up for CN19 (RD13)

    // --- ADC Initialization for Potentiometer ---
    // Assuming potentiometer is on AN5 (often RB5 on PIC24F)
    // Ensure correct TRIS and AD1PCFG/ANSEL for your specific pin connected to AN5
    TRISBbits.TRISB5 = 1;   // Set RB5 (AN5) as input. If AN5 is on another pin, change this.
    AD1PCFG = 0xFFFF;       // Set all ADC pins to digital initially
    AD1PCFGbits.PCFG5 = 0;  // Configure AN5 as analog input (clear PCFGx bit for ANx)
                            // If using a PIC with ANSELx registers: ANSELBbits.ANSB5 = 1;

    ADC_SetConfiguration(ADC_CONFIGURATION_DEFAULT); // Configures ADCONx registers and turns ADON=1
    // ADC_ChannelEnable(ADC_CHANNEL_POTENTIOMETER); // Not strictly needed as AD1PCFG set above

    // --- Change Notification Interrupts for Buttons ---
    // Ensure CN15 is RD6 and CN19 is RD13 for your device, or update CNxxIE bits
    CNEN1bits.CN15IE = 1;  // Enable CN interrupt for CN15 (mapped to RD6)
    CNEN2bits.CN19IE = 1;  // Enable CN interrupt for CN19 (mapped to RD13)

    IFS1bits.CNIF = 0;     // Clear CN Interrupt Flag before enabling
    IPC4bits.CNIP = 5;     // Set CN Interrupt Priority (1-7, 7 is highest. 0 disabled)
    IEC1bits.CNIE = 1;     // Enable CN Interrupts

    // Global interrupts are enabled by default on PIC24F unless IPL is changed.
    // If issues, ensure CPU Interrupt Priority Level allows CN interrupts: SET_CPU_IPL(0); or check SRbits.IPL
}


// --- Main Function ---
int main(void) {
    init(); // Call initialization function

    while (1) {
        zmienProgram = false; // Reset flag before starting/restarting a subprogram

        if (currentProgram == PROGRAM_JEDEN) {
            jeden();
        } else if (currentProgram == PROGRAM_DWA) {
            dwa();
        }
        // If more programs, extend with else if or switch-case
    }

    return 0; // Should not be reached
}
