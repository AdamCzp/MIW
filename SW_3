// --- Konfiguracja bitów konfiguracyjnych (zakładamy te same co w działającym kodzie użytkownika) ---
#pragma config POSCMOD = XT      // Tryb oscylatora: XT
#pragma config OSCIOFNC = ON     // OSC2 jako I/O
#pragma config FCKSM = CSDCMD    // Wyłączenie Clock Switching i Monitor
#pragma config FNOSC = PRI       // Główny oscylator (Primary Oscillator)
#pragma config IESO = ON         // Włączone Internal External Switch Over

#pragma config WDTPS = PS32768   // Watchdog Timer Postscaler
#pragma config FWPSA = PR128     // WDT Prescaler
#pragma config WINDIS = ON       // Watchdog Timer Window Mode (Standard)
#pragma config FWDTEN = OFF      // Watchdog Timer wyłączony
#pragma config ICS = PGx2        // Debugger używa kanału EMUC2/EMUD2
#pragma config GWRP = OFF        // Zapis do pamięci programu dozwolony
#pragma config GCP = OFF         // Ochrona kodu wyłączona
#pragma config JTAGEN = OFF      // Port JTAG wyłączony

#include <xc.h>
#define FCY 4000000UL
#include <libpic30.h>
#include <stdint.h>
#include <stdbool.h>

// --- Definicje dla diod LED ---
#define LED_PORT LATA
#define LED_ONE  0x01     // Mruga dioda podłączona do LATA0
#define LEDS_ALL 0xFF     // Zapala diody LATA0-LATA7 (dostosuj, jeśli używasz innej liczby LED)

// --- Definicje dla alarmu ---
#define ALARM_THRESHOLD 511 // Połowa zakresu ADC (1023 / 2)

// --- Definicje dla Timera1 (do obsługi czasu) ---
#define TIMER1_PRESCALER          256
#define TIMER1_PERIOD_MS          10 // Timer1 generuje przerwanie co 10 ms
// Obliczenie wartości PR1 dla Timera1
// PR1 = (FCY / Preskaler / (1000ms / Okres_Przerwania_ms)) - 1
// PR1 = (4000000 / 256 / (1000 / 10)) - 1 = (15625 / 100) - 1 = 156.25 - 1 = 155
#define PR1_VALUE                 155 

#define FIVE_SECONDS_TICK_COUNT   (5000 / TIMER1_PERIOD_MS) // 500 ticków dla 5 sekund
#define BLINK_TOGGLE_TICK_COUNT   (250 / TIMER1_PERIOD_MS)  // Co 25 ticków zmiana stanu LED (dla okresu ~500ms)

// --- Stany alarmu ---
typedef enum {
    ALARM_STATE_OFF,
    ALARM_STATE_BLINKING,
    ALARM_STATE_ALL_ON
} AlarmState_t;

// --- Zmienne globalne ---
volatile AlarmState_t currentAlarmState = ALARM_STATE_OFF;
volatile uint16_t alarm_duration_ticks = 0;     // Licznik ticków Timera1 dla fazy migania
volatile bool     rd6_button_request = false;   // Flaga żądania wyłączenia alarmu przyciskiem
volatile bool     tick_10ms_event = false;      // Flaga sygnalizująca zdarzenie ticka 10ms

static uint16_t blink_toggle_tick_counter = 0;  // Licznik do zmiany stanu migającej diody

// --- Prototypy funkcji ---
void setup(void);
uint16_t getPotValue(void);

// --- Główna funkcja ---
int main(void) {
    setup();

    while (1) {
        uint16_t potValue = getPotValue();

        // 1. Obsługa żądania wyłączenia alarmu przyciskiem RD6
        if (rd6_button_request) {
            rd6_button_request = false;
            if (currentAlarmState != ALARM_STATE_OFF) {
                currentAlarmState = ALARM_STATE_OFF;
                // Dalsze działania (wyłączenie LED, timera) zostaną obsłużone w logice stanu ALARM_STATE_OFF
            }
        }

        // 2. Obsługa zdarzeń czasowych (np. migotanie) co 10ms
        if (tick_10ms_event) {
            tick_10ms_event = false; // Skonsumuj flagę

            if (currentAlarmState == ALARM_STATE_BLINKING) {
                // Logika migotania pojedynczej diody
                blink_toggle_tick_counter++;
                if (blink_toggle_tick_counter >= BLINK_TOGGLE_TICK_COUNT) {
                    LED_PORT ^= LED_ONE; // Przełącz stan diody LATA0
                    blink_toggle_tick_counter = 0;
                }
            }
        }

        // 3. Maszyna stanów alarmu
        switch (currentAlarmState) {
            case ALARM_STATE_OFF:
                LED_PORT = 0x00;         // Wyłącz wszystkie diody
                T1CONbits.TON = 0;       // Zatrzymaj Timer1 (jeśli był włączony)
                alarm_duration_ticks = 0;

                if (potValue > ALARM_THRESHOLD) {
                    currentAlarmState = ALARM_STATE_BLINKING;
                    alarm_duration_ticks = 0;        // Reset licznika 5 sekund
                    blink_toggle_tick_counter = 0; // Reset licznika migotania
                    LED_PORT = LED_ONE;            // Zapal jedną diodę na start migania
                    
                    TMR1 = 0;                      // Wyzeruj licznik Timera1
                    T1CONbits.TON = 1;             // Włącz Timer1
                }
                break;

            case ALARM_STATE_BLINKING:
                // Sprawdzenie, czy potencjometr spadł poniżej progu
                if (potValue < ALARM_THRESHOLD) {
                    currentAlarmState = ALARM_STATE_OFF; // Zmiana stanu zostanie obsłużona w następnej iteracji
                    break; 
                }

                // Sprawdzenie, czy minęło 5 sekund
                // Zmienna alarm_duration_ticks jest inkrementowana w przerwaniu Timer1
                if (alarm_duration_ticks >= FIVE_SECONDS_TICK_COUNT) {
                    currentAlarmState = ALARM_STATE_ALL_ON;
                    T1CONbits.TON = 0; // Zatrzymaj Timer1, odliczanie 5s zakończone
                                       // Migotanie również nie jest już potrzebne
                }
                // Samo migotanie jest obsługiwane przez blok `if (tick_10ms_event)`
                break;

            case ALARM_STATE_ALL_ON:
                LED_PORT = LEDS_ALL;     // Zapal wszystkie diody
                // T1CONbits.TON = 0;    // Upewnij się, że Timer1 jest wyłączony
                                        // (powinien być już wyłączony po przejściu z BLINKING)
                
                // Sprawdzenie, czy potencjometr spadł poniżej progu
                if (potValue < ALARM_THRESHOLD) {
                    currentAlarmState = ALARM_STATE_OFF; // Zmiana stanu zostanie obsłużona w następnej iteracji
                }
                break;
        }
    } // koniec while(1)
    return 0; // Nigdy nie powinno tu dojść
}

// --- Funkcja inicjalizacyjna ---
void setup(void) {
    // Konfiguracja portu A jako wyjścia dla diod LED
    TRISA = 0x0000;
    LED_PORT = 0x00;

    // Konfiguracja przycisku RD6 (CN15 dla PIC24FJ128GA010) jako wejście
    TRISDbits.TRISD6 = 1;
    // ANSELDbits.ANSD6 = 0; // Jeśli RD6 ma funkcję analogową, ustaw jako cyfrowe (dla GA010 niepotrzebne)

    // Konfiguracja ADC dla potencjometru (AN5) - wzorowana na działającym kodzie użytkownika
    // Upewnij się, że pin fizycznie podłączony do AN5 ma ustawiony TRIS jako wejście,
    // np. jeśli AN5 to RB5: TRISBbits.TRISB5 = 1; (AD1PCFG zajmuje się wyborem funkcji analogowej)
    AD1PCFG = 0xFFDF;       // Ustawia AN5 (bit 5 = 0) jako wejście analogowe, reszta cyfrowe.
                            // Sprawdź, czy pin AN5 na Twojej płytce jest poprawnie skonfigurowany jako wejście (TRIS).
    AD1CON1 = 0x00E0;       // SSRC=111 (auto-convert), ASAM=0, FORM=00
    AD1CON2 = 0x0000;       // VCFG=AVdd/AVss, bez skanowania
    AD1CON3 = 0x1F02;       // SAMC=31 TAD, ADCS=2 (TAD = TCY*3)
    AD1CON1bits.ADON = 1;   // Włącz moduł ADC

    // Konfiguracja przerwań od zmiany stanu (Change Notification) dla RD6 (CN15)
    CNEN1bits.CN15IE = 1;   // Włącz przerwanie CN dla pinu CN15 (RD6)
    IPC4bits.CNIP = 3;      // Ustaw priorytet przerwania CN (np. 3)
    IFS1bits.CNIF = 0;      // Wyczyść flagę przerwania CN
    IEC1bits.CNIE = 1;      // Włącz globalnie przerwania CN

    // Konfiguracja Timera1 do generowania przerwania co 10ms
    T1CONbits.TON = 0;      // Timer wyłączony na starcie
    T1CONbits.TCS = 0;      // Zegar wewnętrzny (FOSC/2)
    T1CONbits.TGATE = 0;    // Gated time accumulation wyłączone
    T1CONbits.TCKPS = 0b11; // Preskaler 1:256
    TMR1 = 0x0000;          // Wyczyść rejestr licznika Timera1
    PR1 = PR1_VALUE;        // Ustaw wartość okresu dla przerwania co 10ms

    IPC0bits.T1IP = 2;      // Ustaw priorytet przerwania Timer1 (np. 2, niższy niż CN)
    IFS0bits.T1IF = 0;      // Wyczyść flagę przerwania Timer1
    IEC0bits.T1IE = 1;      // Włącz przerwania od Timer1
    // T1CONbits.TON = 1;    // Timer zostanie włączony, gdy alarm przejdzie w stan BLINKING
}

// --- Funkcja odczytu wartości z potencjometru (AN5) ---
// Wzorowana na działającym kodzie użytkownika
uint16_t getPotValue(void) {
    AD1CHS = 5;                 // Wybierz kanał AN5
    AD1CON1bits.SAMP = 1;       // Rozpocznij próbkowanie
    __delay_us(10);             // Czas próbkowania (10us)
    AD1CON1bits.SAMP = 0;       // Zakończ próbkowanie, rozpocznij konwersję (dzięki SSRC=111 w AD1CON1)
    while (!AD1CON1bits.DONE);  // Czekaj na zakończenie konwersji
    return ADC1BUF0;            // Zwróć odczytaną wartość
}

// --- Przerwanie od zmiany stanu (CN) dla przycisku RD6 ---
void __attribute__((interrupt, auto_psv)) _CNInterrupt(void) {
    // Sprawdzenie, czy przerwanie pochodzi od RD6 (CN15)
    // Dla prostoty zakładamy, że tylko RD6 generuje to przerwanie, jeśli inne piny CN są aktywne,
    // potrzebna byłaby dodatkowa weryfikacja, który pin spowodował przerwanie.
    if (!PORTDbits.RD6) { // Sprawdź, czy RD6 jest wciśnięty (stan niski)
        __delay_ms(30); // Prosty debouncing
        if (!PORTDbits.RD6) { // Potwierdź wciśnięcie po debounce
            rd6_button_request = true;
        }
    }
    IFS1bits.CNIF = 0; // Zawsze czyść flagę przerwania CN na końcu
}

// --- Przerwanie od Timera1 (co 10ms) ---
void __attribute__((interrupt, auto_psv)) _T1Interrupt(void) {
    IFS0bits.T1IF = 0; // Wyczyść flagę przerwania Timer1
    tick_10ms_event = true;

    // Inkrementuj licznik tylko jeśli alarm jest w fazie migania
    if (currentAlarmState == ALARM_STATE_BLINKING) {
        if (alarm_duration_ticks < UINT16_MAX) { // Zabezpieczenie przed przepełnieniem
             alarm_duration_ticks++;
        }
    }
}
